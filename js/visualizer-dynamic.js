// VIB3CODE Dynamic 4D Visualizer with Theme Engine Integration
(function() {
    'use strict';
    
    function DynamicVisualizer() {
        this.canvas = null;
        this.ctx = null;
        this.gl = null;
        this.isRunning = false;
        this.animationId = null;
        this.time = 0;
        this.audioLevels = { bass: 0, mid: 0, high: 0 };
        
        // Theme-responsive properties
        this.currentTheme = {
            colors: {
                primary: '#00d9ff',
                secondary: '#ff10f0',
                accent: '#ffcc00',
                background: '#0a0a0f'
            },
            intensity: 1.0,
            particleCount: 100,
            animationStyle: 'flowing',
            complexity: 'base'
        };
        
        // Visual elements
        this.particles = [];
        this.hypercube = null;
        this.dataStreams = [];
        
        this.init();
    }
    
    DynamicVisualizer.prototype.init = function() {
        console.log('🎨 Initializing Dynamic Visualizer...');
        
        this.canvas = document.getElementById('visualizer-canvas');
        if (!this.canvas) {
            console.warn('Canvas not found');
            return;
        }
        
        this.setupCanvas();
        this.setupVisualElements();
        this.bindThemeEvents();
        this.start();
        
        // Notify theme engine that visualizer is ready
        window.dispatchEvent(new CustomEvent('visualizerReady'));
        
        console.log('✅ Dynamic Visualizer initialized');
    };
    
    DynamicVisualizer.prototype.setupCanvas = function() {
        var self = this;
        
        this.resizeCanvas();
        
        window.addEventListener('resize', function() {
            self.resizeCanvas();
        });
        
        // Try WebGL first, fallback to 2D
        this.gl = this.canvas.getContext('webgl') || this.canvas.getContext('webgl2');
        if (!this.gl) {
            this.ctx = this.canvas.getContext('2d');
            console.log('Using 2D Canvas fallback');
        } else {\n            console.log('Using WebGL context');\n            this.setupWebGL();\n        }\n    };\n    \n    DynamicVisualizer.prototype.resizeCanvas = function() {\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight;\n        \n        if (this.gl) {\n            this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n        }\n    };\n    \n    DynamicVisualizer.prototype.setupWebGL = function() {\n        var gl = this.gl;\n        \n        // Dynamic fragment shader that responds to theme changes\n        var fsSource = '\n            precision mediump float;\n            uniform vec2 u_resolution;\n            uniform float u_time;\n            uniform vec3 u_primary;\n            uniform vec3 u_secondary;\n            uniform vec3 u_accent;\n            uniform float u_intensity;\n            uniform float u_complexity;\n            \n            vec2 rot2D(vec2 p, float a) {\n                float c = cos(a), s = sin(a);\n                return vec2(p.x * c - p.y * s, p.x * s + p.y * c);\n            }\n            \n            float hypercubeField(vec2 p, float t) {\n                vec2 p1 = p * (3.0 + u_complexity);\n                p1 = rot2D(p1, t * 0.1 * u_intensity);\n                \n                // 4D projection simulation\n                float w = sin(p.x * 2.0 + t * 0.2) * cos(p.y * 2.0 + t * 0.3);\n                vec2 p2 = rot2D(p1 + w * 0.3, w * 0.5 + t * 0.05);\n                \n                // Multi-dimensional grid\n                vec2 grid1 = abs(fract(p1) - 0.5);\n                vec2 grid2 = abs(fract(p2 * 0.7) - 0.5);\n                vec2 grid3 = abs(fract(p * 8.0 + t * 0.1) - 0.5);\n                \n                float lines1 = min(grid1.x, grid1.y);\n                float lines2 = min(grid2.x, grid2.y);\n                float lines3 = min(grid3.x, grid3.y);\n                \n                return mix(mix(lines1, lines2, 0.6), lines3, 0.3);\n            }\n            \n            vec3 dataStreamEffect(vec2 p, float t) {\n                float stream1 = sin(p.y * 10.0 - t * 3.0) * 0.5 + 0.5;\n                float stream2 = sin(p.y * 15.0 - t * 4.0 + 1.0) * 0.5 + 0.5;\n                float stream3 = sin(p.y * 20.0 - t * 2.0 + 2.0) * 0.5 + 0.5;\n                \n                vec3 streams = vec3(stream1, stream2, stream3);\n                \n                // Fade based on x position\n                float fade = 1.0 - smoothstep(0.0, 0.3, abs(p.x));\n                \n                return streams * fade * u_intensity * 0.3;\n            }\n            \n            void main() {\n                vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n                vec2 p = (uv * 2.0 - 1.0) * vec2(u_resolution.x / u_resolution.y, 1.0);\n                \n                // Hypercube field\n                float field = hypercubeField(p, u_time);\n                float grid = 1.0 - smoothstep(0.02, 0.1, field);\n                \n                // Data stream effects\n                vec3 streams = dataStreamEffect(p, u_time);\n                \n                // Theme-based coloring\n                vec3 color = vec3(0.0);\n                \n                // Primary grid structure\n                color += u_primary * grid * u_intensity;\n                \n                // Secondary highlights\n                float highlight = 1.0 - smoothstep(0.01, 0.05, field);\n                color += u_secondary * highlight * u_intensity * 0.7;\n                \n                // Accent details\n                float detail = 1.0 - smoothstep(0.005, 0.02, field);\n                color += u_accent * detail * u_intensity * 0.5;\n                \n                // Data streams\n                color += u_primary * streams.x;\n                color += u_secondary * streams.y;\n                color += u_accent * streams.z;\n                \n                // Background gradient\n                float dist = length(p);\n                vec3 bg = mix(\n                    u_primary * 0.02,\n                    u_secondary * 0.01,\n                    dist * 0.5\n                );\n                \n                color = mix(bg, color, grid + streams.x + streams.y + streams.z);\n                \n                // Subtle glow\n                color += (u_primary + u_secondary + u_accent) * 0.02 * u_intensity;\n                \n                gl_FragColor = vec4(color, 1.0);\n            }\n        ';\n        \n        var vsSource = '\n            attribute vec2 a_position;\n            void main() {\n                gl_Position = vec4(a_position, 0.0, 1.0);\n            }\n        ';\n        \n        // Create shader program\n        this.program = this.createShaderProgram(vsSource, fsSource);\n        if (!this.program) {\n            console.error('Failed to create shader program');\n            return;\n        }\n        \n        // Get locations\n        this.locations = {\n            position: gl.getAttribLocation(this.program, 'a_position'),\n            resolution: gl.getUniformLocation(this.program, 'u_resolution'),\n            time: gl.getUniformLocation(this.program, 'u_time'),\n            primary: gl.getUniformLocation(this.program, 'u_primary'),\n            secondary: gl.getUniformLocation(this.program, 'u_secondary'),\n            accent: gl.getUniformLocation(this.program, 'u_accent'),\n            intensity: gl.getUniformLocation(this.program, 'u_intensity'),\n            complexity: gl.getUniformLocation(this.program, 'u_complexity')\n        };\n        \n        // Create fullscreen quad\n        this.positionBuffer = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n            -1, -1, 1, -1, -1, 1, 1, 1\n        ]), gl.STATIC_DRAW);\n        \n        gl.useProgram(this.program);\n        gl.enableVertexAttribArray(this.locations.position);\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.positionBuffer);\n        gl.vertexAttribPointer(this.locations.position, 2, gl.FLOAT, false, 0, 0);\n    };\n    \n    DynamicVisualizer.prototype.createShaderProgram = function(vsSource, fsSource) {\n        var gl = this.gl;\n        \n        var vertexShader = this.loadShader(gl.VERTEX_SHADER, vsSource);\n        var fragmentShader = this.loadShader(gl.FRAGMENT_SHADER, fsSource);\n        \n        if (!vertexShader || !fragmentShader) {\n            return null;\n        }\n        \n        var shaderProgram = gl.createProgram();\n        gl.attachShader(shaderProgram, vertexShader);\n        gl.attachShader(shaderProgram, fragmentShader);\n        gl.linkProgram(shaderProgram);\n        \n        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n            console.error('Unable to initialize shader program:', gl.getProgramInfoLog(shaderProgram));\n            return null;\n        }\n        \n        return shaderProgram;\n    };\n    \n    DynamicVisualizer.prototype.loadShader = function(type, source) {\n        var gl = this.gl;\n        var shader = gl.createShader(type);\n        \n        gl.shaderSource(shader, source);\n        gl.compileShader(shader);\n        \n        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n            console.error('An error occurred compiling the shaders:', gl.getShaderInfoLog(shader));\n            gl.deleteShader(shader);\n            return null;\n        }\n        \n        return shader;\n    };\n    \n    DynamicVisualizer.prototype.setupVisualElements = function() {\n        // Initialize particles for 2D fallback\n        this.particles = [];\n        for (var i = 0; i < this.currentTheme.particleCount; i++) {\n            this.particles.push({\n                x: Math.random() * this.canvas.width,\n                y: Math.random() * this.canvas.height,\n                vx: (Math.random() - 0.5) * 2,\n                vy: (Math.random() - 0.5) * 2,\n                size: Math.random() * 3 + 1,\n                life: Math.random(),\n                type: Math.floor(Math.random() * 3)\n            });\n        }\n    };\n    \n    DynamicVisualizer.prototype.bindThemeEvents = function() {\n        var self = this;\n        \n        window.addEventListener('themeChange', function(event) {\n            self.updateTheme(event.detail.theme);\n        });\n    };\n    \n    // Main theme update function called by theme engine\n    DynamicVisualizer.prototype.updateTheme = function(newTheme) {\n        console.log('🎨 Visualizer updating theme:', newTheme.name);\n        \n        // Smooth transition to new theme\n        this.transitionToTheme(newTheme);\n    };\n    \n    DynamicVisualizer.prototype.transitionToTheme = function(newTheme) {\n        var self = this;\n        \n        // Store previous theme for interpolation\n        this.previousTheme = JSON.parse(JSON.stringify(this.currentTheme));\n        this.targetTheme = newTheme;\n        this.transitionProgress = 0;\n        this.transitionDuration = 2000; // 2 seconds\n        this.transitionStart = performance.now();\n        \n        // Update particle count if needed\n        var particleDiff = newTheme.particleCount - this.particles.length;\n        if (particleDiff > 0) {\n            for (var i = 0; i < particleDiff; i++) {\n                this.particles.push({\n                    x: Math.random() * this.canvas.width,\n                    y: Math.random() * this.canvas.height,\n                    vx: (Math.random() - 0.5) * 2,\n                    vy: (Math.random() - 0.5) * 2,\n                    size: Math.random() * 3 + 1,\n                    life: Math.random(),\n                    type: Math.floor(Math.random() * 3)\n                });\n            }\n        } else if (particleDiff < 0) {\n            this.particles.splice(newTheme.particleCount);\n        }\n    };\n    \n    DynamicVisualizer.prototype.interpolateTheme = function() {\n        if (!this.targetTheme || this.transitionProgress >= 1) {\n            return;\n        }\n        \n        var elapsed = performance.now() - this.transitionStart;\n        this.transitionProgress = Math.min(elapsed / this.transitionDuration, 1);\n        \n        // Smooth easing function\n        var ease = this.transitionProgress < 0.5 ? \n            2 * this.transitionProgress * this.transitionProgress :\n            1 - Math.pow(-2 * this.transitionProgress + 2, 3) / 2;\n        \n        // Interpolate intensity\n        this.currentTheme.intensity = this.lerp(\n            this.previousTheme.intensity,\n            this.targetTheme.intensity,\n            ease\n        );\n        \n        // Update colors (for WebGL)\n        if (this.targetTheme.colors) {\n            this.currentTheme.colors = this.targetTheme.colors;\n        }\n        \n        // Animation style changes\n        this.currentTheme.animationStyle = this.targetTheme.animationStyle;\n        this.currentTheme.complexity = this.targetTheme.complexity;\n        \n        if (this.transitionProgress >= 1) {\n            this.currentTheme = JSON.parse(JSON.stringify(this.targetTheme));\n            this.targetTheme = null;\n            this.previousTheme = null;\n        }\n    };\n    \n    DynamicVisualizer.prototype.lerp = function(a, b, t) {\n        return a + (b - a) * t;\n    };\n    \n    DynamicVisualizer.prototype.hexToRgb = function(hex) {\n        var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n        return result ? {\n            r: parseInt(result[1], 16) / 255,\n            g: parseInt(result[2], 16) / 255,\n            b: parseInt(result[3], 16) / 255\n        } : { r: 0, g: 0, b: 0 };\n    };\n    \n    DynamicVisualizer.prototype.render = function() {\n        if (!this.isRunning) return;\n        \n        this.time += 0.016;\n        this.interpolateTheme();\n        \n        if (this.gl && this.program) {\n            this.renderWebGL();\n        } else if (this.ctx) {\n            this.render2D();\n        }\n        \n        var self = this;\n        this.animationId = requestAnimationFrame(function() {\n            self.render();\n        });\n    };\n    \n    DynamicVisualizer.prototype.renderWebGL = function() {\n        var gl = this.gl;\n        \n        // Clear\n        gl.clearColor(0.02, 0.02, 0.04, 1.0);\n        gl.clear(gl.COLOR_BUFFER_BIT);\n        \n        // Set uniforms\n        gl.uniform2f(this.locations.resolution, this.canvas.width, this.canvas.height);\n        gl.uniform1f(this.locations.time, this.time);\n        gl.uniform1f(this.locations.intensity, this.currentTheme.intensity);\n        \n        // Complexity mapping\n        var complexityValue = 1.0;\n        switch (this.currentTheme.complexity) {\n            case 'minimal': complexityValue = 0.5; break;\n            case 'refined': complexityValue = 0.8; break;\n            case 'base': complexityValue = 1.0; break;\n            case 'dynamic': complexityValue = 1.3; break;\n            case 'maximum': complexityValue = 1.8; break;\n        }\n        gl.uniform1f(this.locations.complexity, complexityValue);\n        \n        // Convert hex colors to RGB\n        var primary = this.hexToRgb(this.currentTheme.colors.primary);\n        var secondary = this.hexToRgb(this.currentTheme.colors.secondary);\n        var accent = this.hexToRgb(this.currentTheme.colors.accent);\n        \n        gl.uniform3f(this.locations.primary, primary.r, primary.g, primary.b);\n        gl.uniform3f(this.locations.secondary, secondary.r, secondary.g, secondary.b);\n        gl.uniform3f(this.locations.accent, accent.r, accent.g, accent.b);\n        \n        // Draw\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n    };\n    \n    DynamicVisualizer.prototype.render2D = function() {\n        var ctx = this.ctx;\n        \n        // Clear with theme background\n        ctx.fillStyle = this.currentTheme.colors.background;\n        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n        \n        // Update and draw particles\n        for (var i = 0; i < this.particles.length; i++) {\n            var p = this.particles[i];\n            \n            // Update position\n            p.x += p.vx * this.currentTheme.intensity;\n            p.y += p.vy * this.currentTheme.intensity;\n            \n            // Wrap around edges\n            if (p.x < 0) p.x = this.canvas.width;\n            if (p.x > this.canvas.width) p.x = 0;\n            if (p.y < 0) p.y = this.canvas.height;\n            if (p.y > this.canvas.height) p.y = 0;\n            \n            // Update life\n            p.life += 0.01;\n            if (p.life > 1) p.life = 0;\n            \n            // Draw particle with theme colors\n            var alpha = Math.sin(p.life * Math.PI) * this.currentTheme.intensity;\n            var color = p.type === 0 ? this.currentTheme.colors.primary :\n                       p.type === 1 ? this.currentTheme.colors.secondary :\n                       this.currentTheme.colors.accent;\n            \n            ctx.fillStyle = color + Math.floor(alpha * 255).toString(16).padStart(2, '0');\n            ctx.beginPath();\n            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);\n            ctx.fill();\n            \n            // Draw connections\n            for (var j = i + 1; j < this.particles.length; j++) {\n                var p2 = this.particles[j];\n                var dist = Math.sqrt(Math.pow(p.x - p2.x, 2) + Math.pow(p.y - p2.y, 2));\n                \n                if (dist < 100) {\n                    var lineAlpha = (100 - dist) / 100 * alpha * 0.3;\n                    ctx.strokeStyle = this.currentTheme.colors.accent + Math.floor(lineAlpha * 255).toString(16).padStart(2, '0');\n                    ctx.lineWidth = 1;\n                    ctx.beginPath();\n                    ctx.moveTo(p.x, p.y);\n                    ctx.lineTo(p2.x, p2.y);\n                    ctx.stroke();\n                }\n            }\n        }\n    };\n    \n    DynamicVisualizer.prototype.start = function() {\n        if (this.isRunning) return;\n        \n        this.isRunning = true;\n        this.render();\n        \n        console.log('🌊 Dynamic Visualizer started');\n    };\n    \n    DynamicVisualizer.prototype.stop = function() {\n        this.isRunning = false;\n        \n        if (this.animationId) {\n            cancelAnimationFrame(this.animationId);\n            this.animationId = null;\n        }\n        \n        console.log('⏹️ Dynamic Visualizer stopped');\n    };\n    \n    DynamicVisualizer.prototype.destroy = function() {\n        this.stop();\n        \n        if (this.gl && this.program) {\n            this.gl.deleteProgram(this.program);\n        }\n        \n        this.particles = [];\n        \n        console.log('🔥 Dynamic Visualizer destroyed');\n    };\n    \n    // Initialize visualizer\n    var visualizer = new DynamicVisualizer();\n    \n    // Export for theme engine access\n    window.SimpleVisualizer = visualizer;\n    window.DynamicVisualizer = visualizer;\n    \n    // Handle page unload\n    window.addEventListener('beforeunload', function() {\n        visualizer.destroy();\n    });\n    \n    // Pause/resume based on visibility\n    document.addEventListener('visibilitychange', function() {\n        if (document.hidden) {\n            visualizer.stop();\n        } else {\n            visualizer.start();\n        }\n    });\n    \n})();