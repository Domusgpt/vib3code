// 4D Hypercube Visualizer Module for VIB3CODE
// Integrates with existing HyperAV core system

import HypercubeCore from '../core/HypercubeCore.js';\nimport ShaderManager from '../core/ShaderManager.js';\n\nclass VIB3CODEVisualizer {\n    constructor() {\n        this.canvas = null;\n        this.gl = null;\n        this.hypercubeCore = null;\n        this.shaderManager = null;\n        this.audioContext = null;\n        this.analyser = null;\n        this.audioData = new Uint8Array(256);\n        this.isInitialized = false;\n        this.isRunning = false;\n        this.audioLevels = { bass: 0, mid: 0, high: 0 };\n        this.colorScheme = {\n            primary: [0.0, 0.85, 1.0],    // Cyber teal\n            secondary: [1.0, 0.06, 0.94], // Cyber pink\n            background: [0.04, 0.04, 0.06] // Dark background\n        };\n        \n        this.init();\n    }\n    \n    async init() {\n        console.log('🔮 Initializing VIB3CODE Visualizer...');\n        \n        try {\n            await this.setupCanvas();\n            await this.setupWebGL();\n            await this.setupShaders();\n            await this.setupHypercube();\n            this.setupAudioListener();\n            this.setupControls();\n            \n            this.isInitialized = true;\n            console.log('✅ VIB3CODE Visualizer initialized successfully');\n            \n            // Auto-start after a brief delay\n            setTimeout(() => {\n                this.start();\n            }, 1000);\n            \n        } catch (error) {\n            console.error('❌ Failed to initialize visualizer:', error);\n            this.showFallback();\n        }\n    }\n    \n    async setupCanvas() {\n        this.canvas = document.getElementById('visualizer-canvas');\n        if (!this.canvas) {\n            throw new Error('Visualizer canvas not found');\n        }\n        \n        // Set canvas size\n        this.resizeCanvas();\n        \n        // Handle resize events\n        window.addEventListener('resize', this.debounce(() => {\n            this.resizeCanvas();\n        }, 250));\n    }\n    \n    resizeCanvas() {\n        if (!this.canvas) return;\n        \n        const dpr = window.devicePixelRatio || 1;\n        const rect = this.canvas.getBoundingClientRect();\n        \n        this.canvas.width = rect.width * dpr;\n        this.canvas.height = rect.height * dpr;\n        \n        this.canvas.style.width = rect.width + 'px';\n        this.canvas.style.height = rect.height + 'px';\n        \n        if (this.gl) {\n            this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n        }\n        \n        console.log(`📐 Canvas resized: ${this.canvas.width}x${this.canvas.height}`);\n    }\n    \n    async setupWebGL() {\n        const glOptions = {\n            alpha: true,\n            antialias: true,\n            depth: false,\n            premultipliedAlpha: false,\n            preserveDrawingBuffer: false,\n            powerPreference: 'high-performance'\n        };\n        \n        this.gl = this.canvas.getContext('webgl2', glOptions) || \n                  this.canvas.getContext('webgl', glOptions);\n        \n        if (!this.gl) {\n            throw new Error('WebGL not supported');\n        }\n        \n        // Check for required extensions\n        const extensions = [\n            'OES_standard_derivatives',\n            'EXT_shader_texture_lod'\n        ];\n        \n        extensions.forEach(ext => {\n            const extension = this.gl.getExtension(ext);\n            if (!extension) {\n                console.warn(`⚠️ Extension ${ext} not available`);\n            }\n        });\n        \n        console.log('🎨 WebGL context created successfully');\n    }\n    \n    async setupShaders() {\n        // Create geometry and projection managers (simplified for web)\n        const geometryManager = this.createGeometryManager();\n        const projectionManager = this.createProjectionManager();\n        \n        this.shaderManager = new ShaderManager(this.gl, geometryManager, projectionManager);\n        console.log('🎯 Shader manager initialized');\n    }\n    \n    createGeometryManager() {\n        return {\n            getGeometry: (type) => {\n                switch (type) {\n                    case 'hypercube':\n                        return {\n                            getShaderCode: () => this.getHypercubeShaderCode()\n                        };\n                    default:\n                        return {\n                            getShaderCode: () => this.getDefaultGeometryCode()\n                        };\n                }\n            }\n        };\n    }\n    \n    createProjectionManager() {\n        return {\n            getProjection: (type) => {\n                switch (type) {\n                    case 'perspective':\n                        return {\n                            getShaderCode: () => this.getPerspectiveProjectionCode()\n                        };\n                    default:\n                        return {\n                            getShaderCode: () => this.getDefaultProjectionCode()\n                        };\n                }\n            }\n        };\n    }\n    \n    getHypercubeShaderCode() {\n        return `\n            // 4D Hypercube lattice calculation\n            float calculateLattice(vec3 p) {\n                // Transform to 4D space\n                vec4 p4d = vec4(p, u_time * 0.1 * u_rotationSpeed);\n                \n                // Apply 4D rotations\n                mat4 rot = rotXW(u_time * 0.3 * u_rotationSpeed) * \n                          rotYW(u_time * 0.2 * u_rotationSpeed) * \n                          rotZW(u_time * 0.4 * u_rotationSpeed);\n                p4d = rot * p4d;\n                \n                // Audio reactive scaling\n                float audioScale = 1.0 + u_audioBass * 0.3 + u_audioMid * 0.2;\n                p4d *= audioScale;\n                \n                // Grid density with audio influence\n                float density = u_gridDensity + u_audioHigh * 2.0;\n                \n                // Calculate hypercube lattice\n                vec4 gridPos = p4d * density;\n                vec4 gridFract = fract(gridPos);\n                vec4 gridStep = step(0.5, gridFract);\n                \n                // Edge detection for hypercube wireframe\n                float edge = 0.0;\n                \n                // 3D edges (visible in our 3D projection)\n                vec3 edge3d = step(1.0 - u_lineThickness, abs(gridFract.xyz - 0.5));\n                edge += max(edge3d.x * edge3d.y, max(edge3d.y * edge3d.z, edge3d.z * edge3d.x));\n                \n                // 4D edges (creates the hypercube effect)\n                float edge4d = step(1.0 - u_lineThickness * 0.7, abs(gridFract.w - 0.5));\n                edge += edge4d * 0.6;\n                \n                // Shell effect for 4D visualization\n                float shell = abs(sin(length(p4d) * 3.14159 + u_time));\n                shell = smoothstep(0.0, u_shellWidth, shell);\n                edge += shell * 0.3;\n                \n                // Audio reactive pulsing\n                float pulse = sin(u_time * 4.0 + length(p4d) * 2.0) * 0.5 + 0.5;\n                edge += pulse * u_audioMid * 0.2;\n                \n                // Pattern intensity scaling\n                edge *= u_patternIntensity;\n                \n                return clamp(edge, 0.0, 1.0);\n            }\n        `;\n    }\n    \n    getPerspectiveProjectionCode() {\n        return `\n            // Enhanced perspective projection with 4D influence\n            vec3 project4Dto3D(vec4 p4d) {\n                // 4D to 3D projection with perspective\n                float w = p4d.w + 3.0; // Avoid division by zero\n                vec3 projected = p4d.xyz / w;\n                \n                // Apply additional perspective effects\n                float perspective = 1.0 + u_dimension * 0.1;\n                projected *= perspective;\n                \n                return projected;\n            }\n        `;\n    }\n    \n    getDefaultGeometryCode() {\n        return `\n            float calculateLattice(vec3 p) {\n                // Fallback grid pattern\n                vec3 grid = abs(fract(p * u_gridDensity) - 0.5);\n                float edge = smoothstep(u_lineThickness, u_lineThickness * 2.0, \n                                      min(grid.x, min(grid.y, grid.z)));\n                return 1.0 - edge;\n            }\n        `;\n    }\n    \n    getDefaultProjectionCode() {\n        return `\n            // Simple projection\n            vec3 project4Dto3D(vec4 p4d) {\n                return p4d.xyz;\n            }\n        `;\n    }\n    \n    async setupHypercube() {\n        const options = {\n            geometryType: 'hypercube',\n            projectionMethod: 'perspective',\n            dimensions: 4.0,\n            morphFactor: 0.6,\n            rotationSpeed: 0.3,\n            universeModifier: 1.2,\n            patternIntensity: 1.0,\n            gridDensity: 6.0,\n            lineThickness: 0.04,\n            shellWidth: 0.03,\n            colorScheme: this.colorScheme,\n            audioLevels: this.audioLevels,\n            callbacks: {\n                onRender: (state) => this.onRender(state),\n                onError: (error) => this.onError(error)\n            }\n        };\n        \n        this.hypercubeCore = new HypercubeCore(this.canvas, this.shaderManager, options);\n        console.log('🔮 Hypercube core initialized');\n    }\n    \n    setupAudioListener() {\n        // Listen for audio context from main app\n        window.addEventListener('audioContextReady', (event) => {\n            this.audioContext = event.detail.audioContext;\n            this.setupAudioAnalysis();\n        });\n        \n        // Try to use existing audio context if available\n        if (window.VIB3CODE && window.VIB3CODE.audioContext) {\n            this.audioContext = window.VIB3CODE.audioContext;\n            this.setupAudioAnalysis();\n        }\n    }\n    \n    async setupAudioAnalysis() {\n        if (!this.audioContext) return;\n        \n        try {\n            // Get microphone input\n            const stream = await navigator.mediaDevices.getUserMedia({ \n                audio: {\n                    echoCancellation: false,\n                    noiseSuppression: false,\n                    autoGainControl: false\n                } \n            });\n            \n            const source = this.audioContext.createMediaStreamSource(stream);\n            this.analyser = this.audioContext.createAnalyser();\n            \n            this.analyser.fftSize = 512;\n            this.analyser.smoothingTimeConstant = 0.8;\n            \n            source.connect(this.analyser);\n            \n            this.audioData = new Uint8Array(this.analyser.frequencyBinCount);\n            \n            console.log('🎤 Audio analysis setup complete');\n            \n        } catch (error) {\n            console.warn('⚠️ Microphone access denied, using fallback audio');\n            this.setupFallbackAudio();\n        }\n    }\n    \n    setupFallbackAudio() {\n        // Generate synthetic audio data for visualization\n        setInterval(() => {\n            this.generateSyntheticAudio();\n        }, 50); // 20 FPS audio updates\n    }\n    \n    generateSyntheticAudio() {\n        const time = performance.now() * 0.001;\n        \n        // Generate bass, mid, and high frequency data\n        const bass = (Math.sin(time * 2) + Math.sin(time * 3.2)) * 0.5 + 0.5;\n        const mid = (Math.sin(time * 5) + Math.sin(time * 7.3)) * 0.3 + 0.3;\n        const high = (Math.sin(time * 15) + Math.sin(time * 23.7)) * 0.2 + 0.2;\n        \n        // Add some randomness\n        this.audioLevels = {\n            bass: bass * (0.8 + Math.random() * 0.4),\n            mid: mid * (0.8 + Math.random() * 0.4),\n            high: high * (0.8 + Math.random() * 0.4)\n        };\n    }\n    \n    updateAudioLevels() {\n        if (!this.analyser) {\n            return;\n        }\n        \n        this.analyser.getByteFrequencyData(this.audioData);\n        \n        // Calculate frequency bands\n        const bassEnd = Math.floor(this.audioData.length * 0.15);\n        const midEnd = Math.floor(this.audioData.length * 0.6);\n        \n        let bassSum = 0, midSum = 0, highSum = 0;\n        \n        // Bass (0-15%)\n        for (let i = 0; i < bassEnd; i++) {\n            bassSum += this.audioData[i];\n        }\n        \n        // Mids (15-60%)\n        for (let i = bassEnd; i < midEnd; i++) {\n            midSum += this.audioData[i];\n        }\n        \n        // Highs (60-100%)\n        for (let i = midEnd; i < this.audioData.length; i++) {\n            highSum += this.audioData[i];\n        }\n        \n        // Normalize (0-255 to 0-1)\n        this.audioLevels = {\n            bass: (bassSum / bassEnd) / 255,\n            mid: (midSum / (midEnd - bassEnd)) / 255,\n            high: (highSum / (this.audioData.length - midEnd)) / 255\n        };\n        \n        // Apply smoothing\n        const smoothing = 0.7;\n        this.audioLevels.bass = this.audioLevels.bass * (1 - smoothing) + \n                               (this.audioLevels.bass || 0) * smoothing;\n        this.audioLevels.mid = this.audioLevels.mid * (1 - smoothing) + \n                              (this.audioLevels.mid || 0) * smoothing;\n        this.audioLevels.high = this.audioLevels.high * (1 - smoothing) + \n                               (this.audioLevels.high || 0) * smoothing;\n    }\n    \n    setupControls() {\n        // Setup scroll-based parameter changes\n        window.addEventListener('scroll', this.debounce(() => {\n            this.updateScrollBasedParams();\n        }, 50));\n        \n        // Setup mouse-based interaction\n        this.canvas.addEventListener('mousemove', (e) => {\n            this.updateMouseBasedParams(e);\n        });\n        \n        // Setup touch support\n        this.canvas.addEventListener('touchmove', (e) => {\n            e.preventDefault();\n            if (e.touches.length > 0) {\n                this.updateMouseBasedParams(e.touches[0]);\n            }\n        });\n    }\n    \n    updateScrollBasedParams() {\n        const scrollPercent = window.pageYOffset / (document.documentElement.scrollHeight - window.innerHeight);\n        \n        if (this.hypercubeCore) {\n            this.hypercubeCore.updateParameters({\n                rotationSpeed: 0.2 + scrollPercent * 0.3,\n                patternIntensity: 0.8 + scrollPercent * 0.4,\n                morphFactor: 0.5 + scrollPercent * 0.5\n            });\n        }\n    }\n    \n    updateMouseBasedParams(e) {\n        const rect = this.canvas.getBoundingClientRect();\n        const x = (e.clientX - rect.left) / rect.width;\n        const y = (e.clientY - rect.top) / rect.height;\n        \n        if (this.hypercubeCore) {\n            this.hypercubeCore.updateParameters({\n                gridDensity: 4 + x * 8,\n                universeModifier: 0.8 + y * 0.8,\n                colorShift: (x - 0.5) * 0.2\n            });\n        }\n    }\n    \n    start() {\n        if (!this.isInitialized || this.isRunning) return;\n        \n        console.log('🎬 Starting VIB3CODE Visualizer');\n        \n        if (this.hypercubeCore) {\n            this.hypercubeCore.start();\n        }\n        \n        this.isRunning = true;\n        this.startAudioLoop();\n    }\n    \n    startAudioLoop() {\n        const updateAudio = () => {\n            if (!this.isRunning) return;\n            \n            this.updateAudioLevels();\n            \n            // Update hypercube with audio data\n            if (this.hypercubeCore) {\n                this.hypercubeCore.updateParameters({\n                    audioLevels: this.audioLevels\n                });\n            }\n            \n            requestAnimationFrame(updateAudio);\n        };\n        \n        updateAudio();\n    }\n    \n    stop() {\n        if (!this.isRunning) return;\n        \n        console.log('⏹️ Stopping VIB3CODE Visualizer');\n        \n        this.isRunning = false;\n        \n        if (this.hypercubeCore) {\n            this.hypercubeCore.stop();\n        }\n    }\n    \n    showFallback() {\n        // Show a CSS-based fallback if WebGL fails\n        this.canvas.style.background = `\n            linear-gradient(135deg, #0a0a0f 0%, #151529 100%),\n            radial-gradient(circle at 20% 80%, rgba(0, 217, 255, 0.1) 0%, transparent 50%),\n            radial-gradient(circle at 80% 20%, rgba(255, 16, 240, 0.1) 0%, transparent 50%)\n        `;\n        \n        // Add animated gradient\n        this.canvas.style.animation = 'gradient-shift 6s ease-in-out infinite';\n        \n        console.log('🎨 Fallback visualization active');\n    }\n    \n    onRender(state) {\n        // Performance monitoring\n        if (Math.random() < 0.01) { // 1% sampling\n            console.log(`🎯 Visualizer FPS: ~${Math.round(1000 / (state.deltaTime * 1000 || 16))}`);\n        }\n    }\n    \n    onError(error) {\n        console.error('❌ Visualizer error:', error);\n        this.showFallback();\n    }\n    \n    // Utility functions\n    debounce(func, wait) {\n        let timeout;\n        return function executedFunction(...args) {\n            const later = () => {\n                clearTimeout(timeout);\n                func(...args);\n            };\n            clearTimeout(timeout);\n            timeout = setTimeout(later, wait);\n        };\n    }\n    \n    // Public API\n    setColorScheme(scheme) {\n        this.colorScheme = { ...this.colorScheme, ...scheme };\n        if (this.hypercubeCore) {\n            this.hypercubeCore.updateParameters({ colorScheme: this.colorScheme });\n        }\n    }\n    \n    setParameters(params) {\n        if (this.hypercubeCore) {\n            this.hypercubeCore.updateParameters(params);\n        }\n    }\n    \n    // Cleanup\n    destroy() {\n        console.log('🔥 Destroying VIB3CODE Visualizer');\n        \n        this.stop();\n        \n        if (this.hypercubeCore) {\n            this.hypercubeCore.dispose();\n        }\n        \n        if (this.audioContext) {\n            this.audioContext.close();\n        }\n        \n        this.canvas = null;\n        this.gl = null;\n    }\n}\n\n// Initialize visualizer\nconst visualizer = new VIB3CODEVisualizer();\n\n// Export for external control\nwindow.VIB3CODEVisualizer = visualizer;\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n    visualizer.destroy();\n});\n\nexport default VIB3CODEVisualizer;